import plotly.graph_objects as go
import io
import streamlit as st
from streamlit.runtime.scriptrunner import get_script_run_context

def is_mobile_device():
    ctx = get_script_run_context()
    if ctx and ctx.client:
        ua = ctx.client.browser_user_agent.lower()
        return any(x in ua for x in ['iphone', 'android', 'mobile'])
    return False
import pandas as pd
import gspread
from collections import OrderedDict
from google.oauth2.service_account import Credentials

# Ø¥Ø¹Ø¯Ø§Ø¯ ØµÙØ­Ø© Streamlit
st.set_page_config(layout="wide", page_title="ğŸŒ³ Ø´Ø¬Ø±Ø© Ø§Ù„Ø¹Ø§Ø¦Ù„Ø©")

# ØªØ®ØµÙŠØµ CSS Ø¬Ø¯ÙŠØ¯
st.markdown("""
<style>
    @media only screen and (max-width: 768px) {
        .stSidebar__burger {
            position: fixed !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            left: 0.5rem !important;
            z-index: 9999 !important;
            background-color: #fce4ec !important;
            border-radius: 50% !important;
            width: 40px !important;
            height: 40px !important;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3) !important;
        }
        .stSidebar__burger svg {
            width: 24px !important;
            height: 24px !important;
            stroke: #b30000 !important;
        }
    }
    html, body, .main { background-color: #ffffff !important; }
    
    /* ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„ØªÙ…Ø±ÙƒØ² Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */
    .centered-container {
        display: flex !important;
        justify-content: center !important;
        flex-direction: column !important;
        align-items: center !important;
    }
    .stRadio > div { 
        flex-direction: row !important;
        justify-content: center !important;
    }
    .stSelectbox, .stSlider { width: 80% !important; margin: 0 auto !important; }
    
    /* ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„ØªÙƒØ¨ÙŠØ± Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø© */
    .zoom-container {
        display: flex !important;
        justify-content: center !important;
        gap: 15px !important;
        margin-top: 20px !important;
    }
</style>
""", unsafe_allow_html=True)

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ù„ÙƒØ§Ø´
@st.cache_data
def load_data():
    SCOPE = ["https://spreadsheets.google.com/feeds","https://www.googleapis.com/auth/drive"]
    info = st.secrets["gcp_service_account"]
    creds = Credentials.from_service_account_info(info, scopes=SCOPE)
    client = gspread.authorize(creds)
    SHEET_ID = "1KhHhAInhJGV3NO0YDZjgg86O_0KbBl5aRuXfVIpsfkU"
    sheet = client.open_by_key(SHEET_ID).sheet1
    data = sheet.get_all_records()
    df = pd.DataFrame(data)
    df["order"] = df.index
    df = df.loc[:, ~df.columns.str.match(r'^\d+$')]
    df = df.rename(columns={
        'ID':'id','Full Name':'name','Sex (M/F)':'gender',
        'Father ID':'father_id','Date of Birth':'birth','Date of Death':'death'
    })
    return df

# Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
data = load_data()

# Ø²Ø± Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙÙŠ Ø§Ù„Ø£Ø¹Ù„Ù‰
col_refresh = st.columns([1])
with col_refresh[0]:
    if st.button("ğŸ”„ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", key="refresh_top"):
        st.cache_data.clear()
        data = load_data()
        st.rerun()

# Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† Ø§Ù„Ù…Ù…Ø±ÙƒØ²Ø©
st.markdown("<h2 style='text-align:center;color:#222;text-shadow:1px 1px 3px rgba(0,0,0,0.1);'>ğŸŒ³ Ø´Ø¬Ø±Ø© Ø§Ù„Ø¹Ø§Ø¦Ù„Ø©</h2>", unsafe_allow_html=True)
st.markdown(f"<h5 style='text-align:center;color:#444;'>Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙØ±Ø§Ø¯: {len(data)}</h5>", unsafe_allow_html=True)

# Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©
male_color = "#b3e0ff"
female_color = "#fce4ec"
if "zoom" not in st.session_state:
    st.session_state["zoom"] = 1.0

# ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ù…Ø±ÙƒØ²Ø©
with st.container():
    st.markdown("<h3 style='text-align:center;'>ğŸ›ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©</h3>", unsafe_allow_html=True)
    
    # Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø´Ø®Øµ
    col_person = st.columns([1])
    with col_person[0]:
        opts = [f"[{r['id']}] {r['name']}" for _, r in data.iterrows()]
        sel = st.selectbox("ğŸ‘¤ Ø§Ø®ØªØ± Ø´Ø®Øµ", opts, index=0)
    
    # Ù†ÙˆØ¹ Ø§Ù„Ø´Ø¬Ø±Ø©
    col_tree_type = st.columns([1])
    with col_tree_type[0]:
        tree_type = st.radio(
            "ğŸŒ³ Ù†ÙˆØ¹ Ø§Ù„Ø´Ø¬Ø±Ø©",
            ["Ø§Ù„Ø£Ù†Ø³Ø§Ù„ (Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡)", "Ø§Ù„Ø£Ø³Ù„Ø§Ù (Ø§Ù„Ø¢Ø¨Ø§Ø¡)", "Ø§Ù„ÙƒÙ„ (Ø£Ø³Ù„Ø§Ù + Ø£Ù†Ø³Ø§Ù„)"],
            horizontal=True
        )
    
    # Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¬ÙŠØ§Ù„
    col_generations = st.columns([1])
    with col_generations[0]:
        generations = st.slider("ğŸ“š Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¬ÙŠØ§Ù„", 1, 10, 3)
    
    # ØªØ®ØµÙŠØµ Ø§Ù„Ø£Ù„ÙˆØ§Ù†
    with st.expander("ğŸ¨ ØªØ®ØµÙŠØµ Ø§Ù„Ø£Ù„ÙˆØ§Ù†", expanded=False):
        col_colors = st.columns([1,1])
        with col_colors[0]:
            male_color = st.color_picker("ğŸ¨ Ù„ÙˆÙ† Ø§Ù„Ø°ÙƒÙˆØ±", male_color)
        with col_colors[1]:
            female_color = st.color_picker("ğŸ¨ Ù„ÙˆÙ† Ø§Ù„Ø¥Ù†Ø§Ø«", female_color)

person_id = int(sel.split(']')[0].lstrip('['))

# Ø¯ÙˆØ§Ù„ Ø§Ù„Ø´Ø¬Ø±Ø© (Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±)
def get_descendants(df, pid, gens):
    t = OrderedDict({0:[pid]})
    for g in range(1, gens+1):
        if g-1 not in t: break
        cur = []
        for p in t[g-1]:
            kids = df[df['father_id']==p]['id'].tolist()
            cur.extend(kids)
        if cur: t[g] = cur
    return t

def get_ancestors(df, pid, gens):
    t = {0:[pid]}
    for g in range(1, gens+1):
        prev = t.get(g-1, [])
        cur = []
        for c in prev:
            r = df[df['id']==c]
            if not r.empty:
                f = r['father_id'].iloc[0]
                if pd.notna(f): cur.append(f)
        if cur: t[g] = cur
    return t

def merge_trees(a, d):
    return {**{-k:v for k,v in a.items()}, **d}

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Sunburst (Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±)
def prepare_sunburst(df, tree):
    ids, labels, parents, genders, hov = [], [], [], [], []
    info = df.set_index('id').to_dict('index')
    seen = set()

    for depth, nodes in tree.items():
        for n in nodes:
            if n in seen:
                continue
            seen.add(n)
            rec = info.get(n, {})
            nm = rec.get('name', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            g = rec.get('gender', 'M')
            b = rec.get('birth', '')
            dth = rec.get('death', '')
            by = pd.to_datetime(b, errors='coerce').year if b else ''
            dy = pd.to_datetime(dth, errors='coerce').year if dth else ''
            parts = [f"<b>{nm}</b>", f"<span style='color:blue'>{n}</span>"]
            datep = []
            if by:
                datep.append(f"<span style='color:green'>{by}</span>")
            if dy:
                datep.append(f"<span style='color:red'>{dy}</span>")
            labels.append(" â€¢ ".join(parts + datep) if is_mobile_device() else "<br>".join(parts + datep))
            ids.append(str(n))
            genders.append(g)
            fpid = rec.get('father_id', '')
            parents.append(str(int(fpid)) if pd.notna(fpid) and fpid != '' else '')

            # Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© ÙƒÙ…Ø§ Ù‡ÙŠ Ø¨Ø¯ÙˆÙ† ØªØ¹Ø±ÙŠØ¨
            hover_lines = []
            for col in df.columns:
                if col == 'order':
                    continue
                value = rec.get(col, '---')
                if pd.isna(value) or value == '':
                    value = '---'
                hover_lines.append(f"<b>{col}:</b> {value}")
            hov.append("<br>".join(hover_lines))

    return ids, labels, parents, genders, hov

# Ø±Ø³Ù… Ø§Ù„Ø´Ø¬Ø±Ø© (Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±)
def draw(df, tree, mcol, fcol, zoom):
    ids, labels, parents, genders, hov = prepare_sunburst(df, tree)
    cols = [mcol if g == 'M' else fcol for g in genders]
    sz = min(26, max(10, int(18 * zoom)))
    fig = go.Figure(go.Sunburst(
        ids=ids,
        labels=labels,
        parents=parents,
        sort=False,
        marker=dict(colors=cols),
        branchvalues='total',
        hovertext=hov,
        hoverinfo='text',
        insidetextorientation='auto',
        textinfo='label',
        textfont=dict(size=sz)
    ))
    fig.update_layout(margin=dict(t=10, l=10, r=10, b=10), height=int(800 * zoom), width=int(800 * zoom))
    return fig

# ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø´Ø¬Ø±Ø©
if tree_type == "Ø§Ù„Ø£Ù†Ø³Ø§Ù„ (Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡)":
    t = get_descendants(data, person_id, generations)
elif tree_type == "Ø§Ù„Ø£Ø³Ù„Ø§Ù (Ø§Ù„Ø¢Ø¨Ø§Ø¡)":
    t = get_ancestors(data, person_id, generations)
else:
    t = merge_trees(get_ancestors(data, person_id, generations), get_descendants(data, person_id, generations))
fig = draw(data, t, male_color, female_color, st.session_state['zoom'])
st.plotly_chart(fig, use_container_width=True)

# Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ØªÙƒØ¨ÙŠØ± (Ù†Ø³Ø®Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø¹Ø¯Ù„Ø©)
st.markdown("<div class='zoom-container'>", unsafe_allow_html=True)
col1, col2, col3 = st.columns([1,1,1])
with col1:
    if st.button("â– ØªØµØºÙŠØ±", key="zoom_out"):
        st.session_state['zoom'] = max(st.session_state['zoom']-0.1, 0.2)
with col2:
    st.markdown(f"<div style='text-align:center;font-weight:bold;margin-top:8px;'>ğŸ” {st.session_state['zoom']*100:.0f}%</div>", unsafe_allow_html=True)
with col3:
    if st.button("â• ØªÙƒØ¨ÙŠØ±", key="zoom_in"):
        st.session_state['zoom'] = min(st.session_state['zoom']+0.1, 3.0)
st.markdown("</div>", unsafe_allow_html=True)

# Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ­Ù…ÙŠÙ„ (Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±)
for fmt, label in [('png', 'ğŸ—µ ØªØ­Ù…ÙŠÙ„ PNG'), ('pdf', 'ğŸ“„ ØªØ­Ù…ÙŠÙ„ PDF'), ('svg', 'ğŸ”¼ ØªØ­Ù…ÙŠÙ„ SVG')]:
    buf = io.BytesIO()
    fig.write_image(buf, format=fmt)
    st.download_button(label, buf.getvalue(), file_name=f"tree.{fmt}", mime=f"image/{fmt}")
